'use client'

import React, { useState, useRef } from 'react'
import { Zap, Download, FileText, Settings, Eye } from 'lucide-react'
// import { ImageProcessor } from '@/lib/imageProcessor'
// import { LUTGenerator as LUTGen, LUTConfig } from '@/lib/lutGenerator'

interface LutGeneratorProps {
  referenceImage: File | null
  targetImage: File | null
  selectedLUT: any
  referenceAnalysis: any
  targetAnalysis: any
}

interface LutPreview {
  before: string
  after: string
}

export default function LutGenerator({ referenceImage, targetImage, selectedLUT, referenceAnalysis, targetAnalysis }: LutGeneratorProps) {
  const [isGenerating, setIsGenerating] = useState(false)
  const [lutPreview, setLutPreview] = useState<LutPreview | null>(null)
  const [lutData, setLutData] = useState<{ cube: string; threeDL: string } | null>(null)
  const [lutName, setLutName] = useState('Custom_LUT')
  const [imageAnalysis, setImageAnalysis] = useState<any>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)

  // const imageProcessor = new ImageProcessor()
  // const lutGenerator = new LUTGen({
  //   size: 32,
  //   name: lutName,
  //   description: 'Generated by LUT Maker AI'
  // })

  const generateLUT = async () => {
    if (!referenceImage || !targetImage) return

    setIsGenerating(true)
    
    try {
      // Simulate AI-powered LUT generation
      await new Promise(resolve => setTimeout(resolve, 3000))
      
      // Generate LUT based on selected cinematic style
      const lutName = selectedLUT ? `${selectedLUT.name}_LUT` : 'AI_Generated_LUT'
      setLutName(lutName)
      
      const cubeContent = generateCinematicCUBELUT(selectedLUT)
      const threeDLContent = generateCinematic3DLLUT(selectedLUT)
      
      setLutData({ cube: cubeContent, threeDL: threeDLContent })
      
      // Generate preview
      const refImg = await loadImage(referenceImage)
      const targetImg = await loadImage(targetImage)
      setLutPreview({ before: targetImg.src, after: refImg.src })
      
    } catch (error) {
      console.error('Error generating LUT:', error)
    } finally {
      setIsGenerating(false)
    }
  }

  const loadImage = (file: File): Promise<HTMLImageElement> => {
    return new Promise((resolve, reject) => {
      const img = new Image()
      img.onload = () => resolve(img)
      img.onerror = reject
      img.src = URL.createObjectURL(file)
    })
  }

  const generateCinematicCUBELUT = (selectedLUT: any): string => {
    let content = `TITLE "${lutName}"\n\n`
    content += `LUT_3D_SIZE 32\n\n`
    
    for (let b = 0; b < 32; b++) {
      for (let g = 0; g < 32; g++) {
        for (let r = 0; r < 32; r++) {
          const inputR = r / 31
          const inputG = g / 31
          const inputB = b / 31
          
          // Apply cinematic transformation based on selected LUT
          const transformedColor = applyCinematicTransformation(
            { r: inputR, g: inputG, b: inputB },
            selectedLUT
          )
          
          content += `${transformedColor.r.toFixed(6)} ${transformedColor.g.toFixed(6)} ${transformedColor.b.toFixed(6)}\n`
        }
      }
    }
    
    return content
  }

  const applyCinematicTransformation = (inputColor: { r: number; g: number; b: number }, selectedLUT: any) => {
    if (!selectedLUT) {
      // Default transformation
      return {
        r: Math.min(1, inputColor.r * 1.1),
        g: Math.min(1, inputColor.g * 1.05),
        b: Math.min(1, inputColor.b * 1.15)
      }
    }

    // Apply specific cinematic style
    switch (selectedLUT.id) {
      case 'teal-orange':
        return {
          r: Math.min(1, inputColor.r * 1.3), // Boost oranges
          g: Math.min(1, inputColor.g * 0.9), // Reduce greens
          b: Math.min(1, inputColor.b * 1.2)  // Boost teals
        }
      case 'film-noir':
        const bw = (inputColor.r + inputColor.g + inputColor.b) / 3
        return {
          r: Math.min(1, bw * 1.2),
          g: Math.min(1, bw * 1.1),
          b: Math.min(1, bw * 0.9)
        }
      case 'golden-hour':
        return {
          r: Math.min(1, inputColor.r * 1.4), // Warm oranges
          g: Math.min(1, inputColor.g * 1.2), // Warm yellows
          b: Math.min(1, inputColor.b * 0.8)  // Reduce blues
        }
      case 'cyberpunk':
        return {
          r: Math.min(1, Math.abs(inputColor.r - 0.5) * 2), // High contrast
          g: Math.min(1, inputColor.g * 1.5), // Boost greens
          b: Math.min(1, inputColor.b * 1.5)  // Boost blues
        }
      case 'vintage-film':
        return {
          r: Math.min(1, inputColor.r * 1.1 + 0.1), // Slight sepia
          g: Math.min(1, inputColor.g * 1.05 + 0.05),
          b: Math.min(1, inputColor.b * 0.9 + 0.05)
        }
      case 'fire-glow':
        return {
          r: Math.min(1, inputColor.r * 1.6), // Intense reds
          g: Math.min(1, inputColor.g * 1.3), // Warm yellows
          b: Math.min(1, inputColor.b * 0.7)  // Reduce blues
        }
      default:
        return {
          r: Math.min(1, inputColor.r * 1.1),
          g: Math.min(1, inputColor.g * 1.05),
          b: Math.min(1, inputColor.b * 1.15)
        }
    }
  }

  const generateCinematic3DLLUT = (selectedLUT: any): string => {
    let content = `3DMESH\n`
    content += `Mesh 0 32\n`
    
    const meshValues: number[] = []
    for (let i = 0; i < 32; i++) {
      meshValues.push(Math.round((i / 31) * 4095))
    }
    content += meshValues.join(' ') + '\n'
    
    for (let b = 0; b < 32; b++) {
      for (let g = 0; g < 32; g++) {
        for (let r = 0; r < 32; r++) {
          const inputR = r / 31
          const inputG = g / 31
          const inputB = b / 31
          
          const transformedColor = applyCinematicTransformation(
            { r: inputR, g: inputG, b: inputB },
            selectedLUT
          )
          
          const r12bit = Math.round(transformedColor.r * 4095)
          const g12bit = Math.round(transformedColor.g * 4095)
          const b12bit = Math.round(transformedColor.b * 4095)
          
          content += `${r12bit} ${g12bit} ${b12bit}\n`
        }
      }
    }
    
    return content
  }

  const downloadLUT = (format: 'cube' | '3dl') => {
    if (!lutData) return

    const content = format === 'cube' ? lutData.cube : lutData.threeDL
    const filename = `${lutName}.${format}`

    const blob = new Blob([content], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  return (
    <div className="card max-w-4xl mx-auto">
      <h3 className="text-2xl font-bold mb-6 text-center text-white flex items-center justify-center gap-3">
        <Zap className="w-7 h-7 text-primary-400" />
        Generador de LUT Cinematográfico
      </h3>

      {/* Selected LUT Info */}
      {selectedLUT && (
        <div className="mb-6 p-4 bg-gradient-to-r from-primary-500/10 to-purple-500/10 rounded-xl border border-primary-500/20">
          <div className="flex items-center gap-3 mb-3">
            {selectedLUT.icon}
            <div>
              <h4 className="text-lg font-bold text-white">{selectedLUT.name}</h4>
              <p className="text-dark-300 text-sm">{selectedLUT.description}</p>
            </div>
            <div className="ml-auto flex items-center gap-2">
              <span className="px-2 py-1 bg-primary-500/20 text-primary-400 text-xs rounded-full">
                {selectedLUT.category}
              </span>
              <span className="px-2 py-1 bg-purple-500/20 text-purple-400 text-xs rounded-full">
                {selectedLUT.mood}
              </span>
            </div>
          </div>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4 text-sm text-dark-400">
              <span>Intensidad: <span className="text-white">{selectedLUT.intensity}%</span></span>
            </div>
          </div>
        </div>
      )}

      <div className="space-y-6">
        {/* LUT Name Input */}
        <div>
          <label className="block text-sm font-medium text-dark-300 mb-2">
            Nombre del LUT
          </label>
          <input
            type="text"
            value={lutName}
            onChange={(e) => setLutName(e.target.value)}
            className="input-field w-full"
            placeholder="Mi_LUT_Personalizado"
          />
        </div>

        {/* Generate Button */}
        <div className="flex justify-center">
          <button
            onClick={generateLUT}
            disabled={!referenceImage || !targetImage || isGenerating}
            className={`btn-primary flex items-center gap-3 px-8 py-4 text-lg ${
              !referenceImage || !targetImage || isGenerating 
                ? 'opacity-50 cursor-not-allowed' 
                : 'hover:shadow-2xl'
            }`}
          >
            {isGenerating ? (
              <>
                <div className="animate-spin w-6 h-6 border-2 border-white border-t-transparent rounded-full"></div>
                <span>Generando LUT...</span>
              </>
            ) : (
              <>
                <Zap className="w-6 h-6" />
                <span>Generar LUT</span>
              </>
            )}
          </button>
        </div>

        {/* LUT Preview */}
        {lutPreview && (
          <div className="grid md:grid-cols-2 gap-6">
            <div className="text-center">
              <h4 className="text-lg font-semibold text-white mb-3">Antes</h4>
              <div className="aspect-video bg-dark-800 rounded-xl overflow-hidden">
                <img
                  src={lutPreview.before}
                  alt="Antes"
                  className="w-full h-full object-cover"
                />
              </div>
            </div>
            <div className="text-center">
              <h4 className="text-lg font-semibold text-white mb-3">Después</h4>
              <div className="aspect-video bg-dark-800 rounded-xl overflow-hidden">
                <img
                  src={lutPreview.after}
                  alt="Después"
                  className="w-full h-full object-cover"
                />
              </div>
            </div>
          </div>
        )}

        {/* Download Options */}
        {lutData && (
          <div className="space-y-4">
            <h4 className="text-lg font-semibold text-white text-center">
              Descargar LUT
            </h4>
            
            <div className="grid md:grid-cols-2 gap-4">
              <button
                onClick={() => downloadLUT('cube')}
                className="btn-secondary flex items-center justify-center gap-3"
              >
                <FileText className="w-5 h-5" />
                <span>Formato .cube</span>
                <span className="text-xs text-dark-400">(DaVinci Resolve)</span>
              </button>
              
              <button
                onClick={() => downloadLUT('3dl')}
                className="btn-secondary flex items-center justify-center gap-3"
              >
                <FileText className="w-5 h-5" />
                <span>Formato .3dl</span>
                <span className="text-xs text-dark-400">(Premiere Pro)</span>
              </button>
            </div>

            {/* LUT Info */}
            {imageAnalysis && (
              <div className="p-4 bg-dark-800/50 rounded-xl">
                <h5 className="font-semibold text-white mb-3">Información del LUT Generado:</h5>
                <div className="grid md:grid-cols-2 gap-4 text-sm">
                  <div>
                    <span className="text-dark-400">Tamaño:</span>
                    <span className="ml-2 text-white">32³ (32,768 puntos)</span>
                  </div>
                  <div>
                    <span className="text-dark-400">Colores analizados:</span>
                    <span className="ml-2 text-white">{imageAnalysis.dominantColors.length}</span>
                  </div>
                  <div>
                    <span className="text-dark-400">Brillo original:</span>
                    <span className="ml-2 text-white">{Math.round(imageAnalysis.brightness)}</span>
                  </div>
                  <div>
                    <span className="text-dark-400">Contraste:</span>
                    <span className="ml-2 text-white">{imageAnalysis.contrast.toFixed(1)}</span>
                  </div>
                </div>
              </div>
            )}

            {/* Usage Instructions */}
            <div className="p-4 bg-dark-800/50 rounded-xl">
              <h5 className="font-semibold text-white mb-2">Instrucciones de Uso:</h5>
              <ul className="text-sm text-dark-300 space-y-1">
                <li>• <strong>DaVinci Resolve:</strong> Ve a Color → LUTs → Importar LUTs</li>
                <li>• <strong>Premiere Pro:</strong> Efectos → Color Correction → Lumetri Color → Creative → Look</li>
                <li>• <strong>After Effects:</strong> Efectos → Color Correction → Lumetri Color</li>
                <li>• <strong>Final Cut Pro:</strong> Inspector → Color → LUT</li>
              </ul>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}